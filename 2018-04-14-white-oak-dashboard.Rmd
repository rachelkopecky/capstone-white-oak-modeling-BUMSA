---
title: "White Oak Population Forecast"
resource_files:
- dashboard/states-shape/cb_2016_us_state_500k.shp
- dashboard/unit_bnd/eastunits.shp
- cb_2016_us_state_500k.shp
- eastunits.shp
- cb_2016_us_state_500k.cpg
- cb_2016_us_state_500k.dbf
- cb_2016_us_state_500k.prj
- cb_2016_us_state_500k.shp
- cb_2016_us_state_500k.shp.ea.iso.xml
- cb_2016_us_state_500k.shp.iso.xml
- cb_2016_us_state_500k.shp.xml
- cb_2016_us_state_500k.shx
- eastunits.dbf
- eastunits.shp
- eastunits.shp.xml
- eastunits.shx
- forestry_divisions.cpg
- forestry_divisions.dbf
- forestry_divisions.prj
- forestry_divisions.shp
- forestry_divisions.shx
runtime: shiny
output:
  flexdashboard::flex_dashboard:
    logo: bf-logo.png
    orientation: rows
    source_code: embed
    theme: readable
    vertical_layout: fill
---

```{r}
# Change the color of the title bar and the input sidebar. Remove the background from the leaflet map.

```

 <style>                     
.navbar {
  background-color: #C0C0C0;
}

.section.sidebar {
  background-color: #DCDCDC;
}

.leaflet-container {
    background-color:rgba(255,0,0,0.0);
}
</style> 

```{r setup, include=FALSE}
# Load required libraries
library(flexdashboard)
library(tidyverse)
library(ggplot2)
library(shiny)
library(dygraphs)
library(plotly)
library(formattable)
library(leaflet)
library(rgdal)

# Reading in data files to improve dashboard performance
data <- read.csv("WhiteOakData/white-oak-clean.csv")
inventory.map <- read_csv("inventory_map.csv")
inventory.map.unit <- read_csv("inventory_map_unit.csv")
#forecast <- read_csv("forecast_data.csv")
```

Forecast
=======================================================================

*See **Documentation** for explanation of forecast methods.*

Row
-----------------------------------------------------------------------

### White Oak Inventory Forecast *with 95% Confidence Interval*

```{r echo = F,warning=FALSE,message=FALSE,error=FALSE}
#renderPlotly({
  
  # Build plot
#  plt_alt <- ggplot(data = future_plt, aes(x = year, y = forecast_div, linetype = bounds, colour = bounds, size = bounds, group = type)) + 
#    geom_line(aes(text = paste0("Year: ", year, "<br>Forecast: ", formattable::comma(forecast)))) +
#    scale_colour_manual(values = c("maroon", "darkgreen")) +
#    scale_linetype_manual(values = c(3,1)) +
#    scale_size_manual(values = c(1,1)) +
#    theme(panel.background = element_blank(),
#          axis.line = element_line(colour = "black"),
#          legend.position = 'none') +
#    ylab("Inventory (Billions, Cubic Feet)") +
#    xlab("") +
#    scale_y_continuous(limits = c(0,110))
  
  
#  ggplotly(plt_alt, tooltip = 'text')
  
#})
```


Row
-----------------------------------------------------------------------

### Current Inventory (2014) by FIA Unit

```{r merge_shapes, echo = F,warning=FALSE,message=FALSE,error=FALSE}

# Read in state shape file
states.shp <- readOGR("MapFiles", layer = "cb_2016_us_state_500k",
                      GDAL1_integer64_policy = TRUE, verbose = FALSE)

# Remove non-contiguous states/territories
states.shp <- subset(states.shp, !states.shp$STUSPS %in% c("AK", "GU", "MP", "VI", "AS", "PR", "HI"))

# Merge shape and inventory files
states.shp <- sp::merge(states.shp, inventory.map, by = "STUSPS")

stusps <- as.vector(as.character(states.shp@data$STUSPS))

# Read in unit shape file (from US forest service)
units.shp <- readOGR("MapFiles", layer = "eastunits",
                     GDAL1_integer64_policy = TRUE, verbose = FALSE)

# Merge inventory and shape files. Log transform for a more distinct break in heat map colors. 
units.shp <- sp::merge(units.shp, inventory.map.unit, by = "UNIT")
units.shp@data <- units.shp@data[complete.cases(units.shp@data),]
units.shp@data$tot[units.shp@data$tot == 0] <- min(units.shp@data$tot[units.shp@data$tot > 0])-5000
units.shp@data$tot.log <- log(units.shp@data$tot)

# Read in region shape file (custom generated file)
regions.shp <- readOGR("MapFiles", layer = "forestry_divisions",
                     GDAL1_integer64_policy = TRUE, verbose = FALSE)

# Build map
output$inventory_map_rm <- renderLeaflet({
  
  # Set id to state abbreviation
  id <- as.vector(regions.shp@data$NAME)
  
  leaflet(units.shp, options = leafletOptions(zoomControl = FALSE))%>%
    addPolygons(color = '#444444', weight = 1, smoothFactor = 0.5,
                opacity = 1.0, fillOpacity = 0.5,
                fillColor = ~colorNumeric("YlGn", tot.log)(tot.log)) %>%
    # Layer transparent state shapes over units for state boundries
    addPolygons(data = states.shp, color = '#000000', weight = 1, smoothFactor = 0.5,
                opacity = 1.0, fillOpacity = 0) %>%
    # Layer transparent forestry regions over map for clickable regions
    addPolygons(data = regions.shp, layerId = id, color = '#000000', weight = 1, smoothFactor = 0.5,
                opacity = 1.0, fillOpacity = 0, label = id,
                highlightOptions = highlightOptions(color = "gray", weight = 2,
                                                    bringToFront = TRUE))      
  
})

leafletOutput('inventory_map_rm')
```


### Inventory Forecast by Region *with 95% Confidence Interval*

```{r echo = F,warning=FALSE,message=FALSE,error=FALSE}
data$STATE_ABBR <- as.character(data$STATE_ABBR)

# renderPlotly for inputs to work
renderPlotly({
  # Store the id from the map click
  region.alt <- as.character(input$inventory_map_rm_shape_click$id)
  
  # Validate statement to return a helpful error if they haven't yet clicked on a state.
  # Filter data to the selected state.  
  validate(need(try(region.alt <-
                      filter(data, STATE_ABBR == region.alt))
                , "Click on a state to the left to view the state-level forecast."))
  
  state.data.alt <- state.data.alt[, c(1, 2, 5:7)] %>%
    group_by(STATE_ABBR, EVAL_GRP_YEAR) %>%
    summarise_all(funs(sum(., na.rm = TRUE)))
  
  state.inv.alt <- inv.state.rolled %>%
    select(STATE_ABBR, EVAL_GRP_YEAR, SELECT_WHITE_OAK_INV_CUFT_GS) %>%
    group_by(STATE_ABBR, EVAL_GRP_YEAR) %>%
    summarise(tot = sum(SELECT_WHITE_OAK_INV_CUFT_GS, na.rm = TRUE))
  
  state.mod.alt <-
    merge(state.data.alt, state.inv.alt, by = c("STATE_ABBR", "EVAL_GRP_YEAR"))
  
  colnames(state.mod.alt)[3:6] <-
    c("total.growth",
      "total.mortality",
      "total.removal",
      "inv.gs")
  
  state.mod.alt$growth.change <- state.mod.alt$total.growth / state.mod.alt$inv.gs
  state.mod.alt$mortality.change <- state.mod.alt$total.mortality / state.mod.alt$inv.gs
  state.mod.alt$removal.change <- state.mod.alt$total.removal / state.mod.alt$inv.gs
  
  state.mod.alt <-
    filter(state.mod.alt, EVAL_GRP_YEAR <= 2014 & EVAL_GRP_YEAR >= 1991)
  
  #check for consecutive years
  validate(need(try(state.mod.alt$conesc <- 2), "There is no data associated with the selected state. Please select a colored state on the map to view the state level forecast."))
  
  # Validate statement to return a helpful error if the selected state does not have associated data.
  validate(need(try(model_growth_st <- lm(growth.change ~ c(1:num.alt), data = state.mod.alt))
                , "There is no forecast available for selected state."))
  model_mortality_st <- lm(mortality.change ~ c(1:num.alt), data = state.mod.alt)
  model_removal_st <- lm(removal.change ~ c(1:num.alt), data = state.mod.alt)
  
  plt_st_alt <- ggplot(data = future_plt, aes(x = year, y = forecast_div, linetype = bounds, colour = bounds, size = bounds, group = type)) + 
    geom_line(aes(text = paste0("Year: ", year, "<br>Forecast: ", formattable::comma(forecast)))) +
    scale_colour_manual(values = c("maroon", "darkgreen")) +
    scale_linetype_manual(values = c(3,1)) +
    scale_size_manual(values = c(1,1)) +
    theme(panel.background = element_blank(),
          axis.line = element_line(colour = "black"),
          legend.position = 'none') +
    ylab(paste0(unique(state.mod.alt$STATE_ABBR)," Inventory (Billions, Cubic Feet)")) +
    xlab("")
  
  
  ggplotly(plt_st_alt, tooltip = 'text')
  
})
```

Forecast Data
=======================================================================

Inputs {.sidebar}
-----------------------------------------------------------------------

\

The data displayed to the right includes the values selected for Annual increase in Removal and/or Urbanization from the prior tabs. 

Enter Brown-Forman's demand for White Oak in the year `r max(data$EVAL_GRP_YEAR)-3`:

\

```{r}
numericInput("demand", label = paste0("Brown-Forman ", max(data$EVAL_GRP_YEAR)-3," Demand:"), 360000, min = 0, max = 1000000000)
```

\

Use the sliding bar below to adjust the increase in Annual Demand to analyze the portion of Total Inventory and Total Removal that B-F Demand occupies.

```{r}
tags$style(HTML(".js-irs-3 .irs-single, .js-irs-3 .irs-bar-edge, .js-irs-3 .irs-bar {background: green}"))

sliderInput("bf_demand", label = "Brown-Forman Annual Demand Increase (%):",
            min = 0.0, max = 20.0, value = 10.0, step = 0.5)
```

Row
-----------------------------------------------------------------------

```{r echo = F,warning=FALSE,message=FALSE,error=FALSE}

```

Simulation
=======================================================================
```{r simulation}

```

In the simulation outline below, we sample from a normal distribution with a mean equal to the coefficient of a linear model and a standard deviation equal to the standard error on the coefficient estimate in order to obtain rate of change values the growth, removal, and mortality percent of inventory. We then calculate the new percent of inventory each year by multiplying the number of years elapsed by the rate of chance (ROC) and add an intercept (calculated by taking the mean of the last 5 years of data). We also include a yearly shock value to provide a simple example of how we can incorporate the outside variables like wildfire, pests, drought, etc. The initial inventory value is the true inventory in the year 2014, and each subsequent year is calculated by adding/subtracting the growth, removal, mortality, and yearly shock values.

```{r evaluate = FALSE}

```

Documentation
=======================================================================

#### *Conclusion/Result*

**The white oak population will stay relatively flat in the near term.** Due to limited historical data, it is important to use caution when interpreting these results further into the forecast horizon. With only 13 annual data points to build the forecast, looking out past ten years serves best as a directional indication of the White Oak population.

#### *Methodology*

To build a forecast for the white oak population over the next 50 years, we decided to use a **simulation**. A simulation will allow us to forecast current trends in growth, removal, and mortality, as well as incorporate variables to capture the rare events such as catastrophic wildfires, category 5 tornados, and large-scale pest outbreaks. These are events that we would not expect to occur every year, or even once every 10 years. Therefore, by incorporating the probability of these events to occur each year we are able to get a better understanding of how potential environmental disasters can impact the population.

Included in the simulation is the current trend of growth, removal, and mortality, as well as the associated error so that we can be sure to capture the full range of where we might expect the population to be. These trends, as well as the potential for environmental outbreaks, will give us a final forecast that will be based off the average of all the simulated outcomes, and that should be relatively close to where we would expect the true population to be over the next few years.

#### *Purpose*

The Brown-Forman production team has requested a forecast of the White Oak population in order to better understand any short and/or long term risk associated with the population growth and mortality. A previous consultant had provided a forecast that had some fairly significant errors, and our goal was to enhance the consultant's work so that the resulting forecast is up-to-date and accurate.

#### *Data*

The data used for this analysis was received from the U.S. Forest Service. The data contains annual, unit level volumes for White Oak on private, non-industrial lands in the Eastern states, and includes detail on the Growing Stock Inventory, Growth, Removal, and Mortality in cubic feet. The data spans the period 2013 through 2014.

#### *Simulation Dashboard*

In order to forecast the White Oak population, we first calculated the yearly percent of inventory for the growth, removal, and mortality volumes. We then built a simple linear regression model to describe the trend of the growth, removal, and mortality, individually. Using the slope coefficient and an intercept based off the average of the percent of inventory for 2010 to 2014, we predicted the growth, removal, and mortality percent of inventory for the years 2015 through 2064. Using these values, as well as user-input values for annual urbanization percent of inventory, we calculated a forecast for the White Oak inventory.

As well as an inventory forecast, we also provide an upper bound and a lower bound (95% confidence interval), based off of the upper and lower estimates for the slope coefficient from the model. The 95% confidence interval means that we are 95% confident that the true values lies somewhere between the upper and lower bounds.
---
title: "White Oak Population Forecast"
resource_files:
- dashboard/states-shape/cb_2016_us_state_500k.shp
- dashboard/unit_bnd/eastunits.shp
- cb_2016_us_state_500k.shp
- eastunits.shp
- cb_2016_us_state_500k.cpg
- cb_2016_us_state_500k.dbf
- cb_2016_us_state_500k.prj
- cb_2016_us_state_500k.shp
- cb_2016_us_state_500k.shp.ea.iso.xml
- cb_2016_us_state_500k.shp.iso.xml
- cb_2016_us_state_500k.shp.xml
- cb_2016_us_state_500k.shx
- eastunits.dbf
- eastunits.shp
- eastunits.shp.xml
- eastunits.shx
- national_forestry_service_regions.cpg
- national_forestry_service_regions.dbf
- national_forestry_service_regions.prj
- national_forestry_service_regions.qpj
- national_forestry_service_regions.shp
- national_forestry_service_regions.shx
runtime: shiny
output:
  flexdashboard::flex_dashboard:
    orientation: rows
    source_code: embed
    theme: readable
    vertical_layout: fill
---

```{r}
# Change the color of the title bar and the input sidebar. Remove the background from the leaflet map.
```

 <style>                     
.navbar {
  background-color: #C0C0C0;
}

.section.sidebar {
  background-color: #DCDCDC;
}

.leaflet-container {
    background-color:rgba(255,0,0,0.0);
}
</style> 

```{r setup, include=FALSE}
# Load required libraries
library(flexdashboard)
library(tidyverse)
library(ggplot2)
library(shiny)
library(dygraphs)
library(plotly)
library(formattable)
library(leaflet)
library(rgdal)

# Read in the data. This data was cleaned and merged in the for_dashboard.R script.
data <- read.csv("WhiteOakData/white-oak-clean.csv")

data[is.na(data)] <- 0

# Aggregate the growth, removal, and mortality data to the country level
national <- data %>% 
  group_by(EVAL_GRP_YEAR) %>%
  summarise(total.growth = sum(SELECT_WHITE_OAK_GROWTH, na.rm = TRUE),
            total.mortality = sum(SELECT_WHITE_OAK_MORTALITY, na.rm = TRUE),
            total.removal = sum(SELECT_WHITE_OAK_REMOVAL, na.rm = TRUE))

# Read in and manipulate inventory data. These are the raw files from the US Forest service.
inv23 <- read_csv("WhiteOakData/white_oak_inv_23.csv")
inv24 <- read_csv("WhiteOakData/white_oak_inv_24.csv")
inv33 <- read_csv("WhiteOakData/white_oak_inv_33.csv")

inventory <- rbind(inv23, inv24, inv33)

inventory[is.na(inventory)] <- 0

# Create an identifier to merge with the shape files later.
inventory$UNIT <- paste0(inventory$STATECD, "0", inventory$UNITCD)

# Don't think I need both of these next two
inventory.state <- inventory[,c(3,5,6,10:27)] %>%
  group_by(STATE_ABBR, EVAL_GRP_YEAR, UNITCD) %>% 
  summarise_all(funs(sum(., na.rm = TRUE)))

inv.state.rolled <- inventory.state[,c(1,2,4:21)] %>% 
  group_by(STATE_ABBR, EVAL_GRP_YEAR) %>%
  summarise_all(funs(sum(., na.rm = TRUE)))

# Aggregate to unit level inventory for heat map.
inv.unit.rolled <- inventory[,c(3,5,31,10:27)] %>% 
  group_by(STATE_ABBR, EVAL_GRP_YEAR, UNIT) %>% 
  summarise_all(funs(sum(., na.rm = TRUE)))

# Create list of unique states in the growth/removal/mortality data and filter the inventory data so that all states appear in both sets.
state_list <- unique(data$STATE_ABBR)

inv_national <- inv.state.rolled %>%
  filter(STATE_ABBR %in% state_list) 

# Aggregate the inventory data to the country level.
inv_national <- inv_national[2:20] %>% 
  group_by(EVAL_GRP_YEAR) %>% 
  summarise_all(funs(sum(., na.rm = TRUE)))

# Select relevant columns and merge the national inventory data with the national growth/removal/mortality data.
inventory_national <- inv_national %>% 
  select(EVAL_GRP_YEAR, SELECT_WHITE_OAK_INV_CUFT_GS, SELECT_WHITE_OAK_INV_CUFT_LIVE)

national <- merge(national, inventory_national, by = "EVAL_GRP_YEAR")

colnames(national)[5:6] <- c("inv.gs", "inv.live")

national$growth.pct <- 0
national$mortality.pct <- 0
national$removal.pct <- 0

# Calculate the growth/removal/mortality percent of growing stock inventory.
national$growth.pct <- national$total.growth/national$inv.gs
national$mortality.pct <- national$total.mortality/national$inv.gs
national$removal.pct <- national$total.removal/national$inv.gs
  
# Exclude data prior to 1991 and after 2014. All units were not sampled prior to 1991, and '15, `16 and `17 data may be incomplete per US Forest Service.
national <- filter(national, EVAL_GRP_YEAR <= 2014 & EVAL_GRP_YEAR >= 1991)

# Build models. I regressed against the values 1:24 so I could verify the intercept. Whether you regress against this or the actual year values, the slope remains the same.
model_growth <- lm(growth.pct ~ c(1:24), data = national)
model_mortality <- lm(mortality.pct ~ c(1:24), data = national)
model_removal <- lm(removal.pct ~ c(1:24), data = national)

# Store slope coefficients
growth_slope <- coef(model_growth)[[2]]
mortality_slope <- coef(model_mortality)[[2]]
removal_slope <- coef(model_removal)[[2]]

# Store upper and lower bounds on slope coefficients
growth_slope_upper <- confint(model_growth)[4]
growth_slope_lower <- confint(model_growth)[2]

mortality_slope_upper <- confint(model_mortality)[4]
mortality_slope_lower <- confint(model_mortality)[2]

removal_slope_upper <- confint(model_removal)[4]
removal_slope_lower <- confint(model_removal)[2]

# Use average of 2010 - 2014 as intercept
growth_int <- mean(national$growth.pct[20:24])
mortality_int <- mean(national$mortality.pct[20:24])
removal_int <- mean(national$removal.pct[20:24])
```

Forecast
=======================================================================

Inputs {.sidebar}
-----------------------------------------------------------------------

\

\

Use the sliding bar below to adjust the increase in Annual Urbanization to see the effect this factor can have on the White Oak Population.

\

```{r echo = F,warning=FALSE,message=FALSE,error=FALSE}
# Change the color of the input sliders.
tags$style(HTML(".js-irs-2 .irs-single, .js-irs-2 .irs-bar-edge, .js-irs-2 .irs-bar {background: green}"))

sliderInput("urbanization2", label = "Annual Urbanization (% of White Oak Inventory):",
            min = 0.0, max = 1.0, value = 0.1, step = 0.1)
```

\

\

*See **Documentation** for explanation of forecast methods.*

Row
-----------------------------------------------------------------------

### White Oak Inventory Forecast *with 95% Confidence Interval*

```{r echo = F,warning=FALSE,message=FALSE,error=FALSE}
# Build "forecast" dataframe
future_alt <- NULL
future_alt$year <- 2014:2064
future_alt <- data.frame(future_alt)

future_alt$inventory <- 0
future_alt$inventory.high <- 0
future_alt$inventory.low <- 0
future_alt$growth <- 0
future_alt$growth.high <- 0
future_alt$growth.low <- 0
future_alt$removals <- 0
future_alt$removal.low <- 0
future_alt$removal.high <- 0
future_alt$mortality <- 0
future_alt$mortality.high <- 0
future_alt$mortality.low <- 0
future_alt$urbanization <- 0
future_alt$urbanization.high <- 0
future_alt$urbanization.low <- 0
future_alt$demand <- 0
future_alt$`demand % of inventory` <- 0
future_alt$`demand % of removals` <- 0

# Fill in data for 2014
inv_14 <- inventory_national %>% 
  filter(EVAL_GRP_YEAR == 2014) %>% 
  select(SELECT_WHITE_OAK_INV_CUFT_GS)

future_alt$inventory[1] <- as.numeric(inv_14[1,1])
future_alt$inventory.high[1] <- as.numeric(inv_14[1,1])
future_alt$inventory.low[1] <- as.numeric(inv_14[1,1])
future_alt$growth[1] <- national$total.growth[nrow(national)]
future_alt$removal.high[1] <- national$total.removal[nrow(national)]
future_alt$removal.low[1] <- national$total.removal[nrow(national)]
future_alt$removals[1] <- national$total.removal[nrow(national)]
future_alt$mortality[1] <- national$total.mortality[nrow(national)]
future_alt$growth.high[1] <- national$total.growth[nrow(national)]
future_alt$mortality.high[1] <- national$total.mortality[nrow(national)]
future_alt$growth.low[1] <- national$total.growth[nrow(national)]
future_alt$mortality.low[1] <- national$total.mortality[nrow(national)]

# Calculate growth and mortality % "forecast"
future_alt$dummy <- 0:50

future_alt$new_growth <- ((future_alt$dummy*growth_slope)+growth_int)
future_alt$new_mortality <- ((future_alt$dummy*mortality_slope)+mortality_int)
future_alt$new_removal <- ((future_alt$dummy*removal_slope)+removal_int)

future_alt$high_growth <- ((future_alt$dummy*growth_slope_upper)+growth_int)
future_alt$high_mortality <- ((future_alt$dummy*mortality_slope_upper)+mortality_int)
future_alt$high_removal <- ((future_alt$dummy*removal_slope_upper)+removal_int)

future_alt$low_growth <- ((future_alt$dummy*growth_slope_lower)+growth_int)
future_alt$low_mortality <- ((future_alt$dummy*mortality_slope_lower)+mortality_int)
future_alt$low_removal <- ((future_alt$dummy*removal_slope_lower)+removal_int)

# growth, removal, mortality cannot be a negative % of inventory
future_alt$low_removal <- ifelse(future_alt$low_removal <= 0, 0, future_alt$low_removal)
future_alt$low_growth <- ifelse(future_alt$low_growth <= 0, 0, future_alt$low_growth)
future_alt$low_mortality <- ifelse(future_alt$low_mortality <= 0, 0, future_alt$low_mortality)

future_alt$high_removal <- ifelse(future_alt$high_removal <= 0, 0, future_alt$high_removal)
future_alt$high_growth <- ifelse(future_alt$high_growth <= 0, 0, future_alt$high_growth)
future_alt$high_mortality <- ifelse(future_alt$high_mortality <= 0, 0, future_alt$high_mortality)

future_alt$new_removal <- ifelse(future_alt$new_removal <= 0, 0, future_alt$new_removal)
future_alt$new_growth <- ifelse(future_alt$new_growth <= 0, 0, future_alt$new_growth)
future_alt$new_mortality <- ifelse(future_alt$new_mortality <= 0, 0, future_alt$new_mortality)

future_alt$dummy <- NULL

# renderPlot for inputs to work
# renderggiraph for ggiraph graph
# renderPlotly for plotly graph

renderPlotly({
  
  # fill in forecast table row by row
  for (i in 2:nrow(future_alt)) {
    # Inventory = Inventory + Growth - Removal - Mortality - Urbanization  
    future_alt$inventory[i] <- future_alt$inventory[i-1] + future_alt$growth[i-1] - future_alt$removals[i-1] - future_alt$mortality[i-1] - future_alt$urbanization[i-1]
    
    # Upper Bound Inventory = Upper Bound Inventory + High Growth - Low Removal - Low Mortality - High Urbanization (i.e. the Urbanization calculated from the High Inventory)
    future_alt$inventory.high[i] <- future_alt$inventory.high[i-1] + future_alt$growth.high[i-1] - future_alt$removal.low[i-1] - future_alt$mortality.low[i-1] - future_alt$urbanization.high[i-1]
    
    # Lower Bound Inventory = Lower Bound Inventory + Low Growth - High Removal - High Mortality - Low Urbanization (i.e. the Urbanization calculated from the Low Inventory)
    future_alt$inventory.low[i] <- future_alt$inventory.low[i-1] + future_alt$growth.low[i-1] - future_alt$removal.high[i-1] - future_alt$mortality.high[i-1] - future_alt$urbanization.low[i-1]
    
    future_alt$growth[i] <- future_alt$inventory[i]*(future_alt$new_growth[i])    
    future_alt$growth.high[i] <- future_alt$inventory.high[i]*(future_alt$high_growth[i])
    future_alt$growth.low[i] <- future_alt$inventory.low[i]*(future_alt$low_growth[i])
    
    future_alt$mortality[i] <- future_alt$inventory[i]*(future_alt$new_mortality[i])
    future_alt$mortality.high[i] <- future_alt$inventory.low[i]*(future_alt$high_mortality[i])
    future_alt$mortality.low[i] <- future_alt$inventory.high[i]*(future_alt$low_mortality[i])
    
    future_alt$removals[i] <- future_alt$inventory[i]*future_alt$new_removal[i]
    future_alt$removal.high[i] <- future_alt$inventory.low[i]*future_alt$high_removal[i]
    future_alt$removal.low[i] <- future_alt$inventory.high[i]*future_alt$low_removal[i]
    
    future_alt$urbanization[i] <- future_alt$inventory[i]*(as.numeric(input$urbanization2)/100)
    future_alt$urbanization.high[i] <- future_alt$inventory.high[i]*(as.numeric(input$urbanization2)/100)
    future_alt$urbanization.low[i] <- future_alt$inventory.low[i]*(as.numeric(input$urbanization2)/100)
    
  }
  
  future_alt$inventory <- round(as.numeric(future_alt$inventory),0)
  future_alt$inventory.high <- round(as.numeric(future_alt$inventory.high),0)
  future_alt$inventory.low <- round(as.numeric(future_alt$inventory.low),0)  
  
  # Select relevant columns for inventory plot.
  future_plt <- select(future_alt, year, inventory, inventory.high, inventory.low)
  
  # Transform to long format for easier ggplot use.
  future_plt <- tidyr::gather(future_plt, 
                              key = 'type', 
                              value = 'forecast', 
                              -year)
  
  # Divide by 1 Billion for cleaner y-axis
  future_plt$forecast_div <- future_plt$forecast/1000000000
  
  # Bounds as factors for color differential
  future_plt$bounds <- ifelse(future_plt$type == "inventory", "n", "y")
  future_plt$bounds <- factor(future_plt$bounds, levels = c("y", "n"))
  
  # Build plot
  plt_alt <- ggplot(data = future_plt, aes(x = year, y = forecast_div, linetype = bounds, colour = bounds, size = bounds, group = type)) + 
    geom_line(aes(text = paste0("Year: ", year, "<br>Forecast: ", formattable::comma(forecast)))) +
    scale_colour_manual(values = c("maroon", "darkgreen")) +
    scale_linetype_manual(values = c(3,1)) +
    scale_size_manual(values = c(1,1)) +
    theme(panel.background = element_blank(),
          axis.line = element_line(colour = "black"),
          legend.position = 'none') +
    ylab("Inventory (Billions, Cubic Feet)") +
    xlab("") +
    scale_y_continuous(limits = c(0,110))
  
  
  ggplotly(plt_alt, tooltip = 'text')
  
})
```


Row
-----------------------------------------------------------------------

### Current Inventory (2014) by FIA Unit

```{r echo = F,warning=FALSE,message=FALSE,error=FALSE}
# Aggregate to state level to merge with state shape file
inventory.map <- inv.state.rolled %>%
  select(STATE_ABBR, EVAL_GRP_YEAR, SELECT_WHITE_OAK_INV_CUFT_GS) %>%
  group_by(STATE_ABBR, EVAL_GRP_YEAR) %>%
  summarise(tot = sum(SELECT_WHITE_OAK_INV_CUFT_GS, na.rm = TRUE)) %>%
  filter(EVAL_GRP_YEAR == 2014)

# Aggregate to unit level to merge with unit shape file
inventory.map.unit <- inv.unit.rolled %>%
  select(STATE_ABBR, EVAL_GRP_YEAR, UNIT, SELECT_WHITE_OAK_INV_CUFT_GS) %>%
  group_by(STATE_ABBR, EVAL_GRP_YEAR, UNIT) %>%
  summarise(tot = sum(SELECT_WHITE_OAK_INV_CUFT_GS)) %>%
  filter(EVAL_GRP_YEAR == 2014)

colnames(inventory.map)[1] <- "STUSPS"

# Read in state shape file
states_shp <- readOGR("MapFiles", layer = "cb_2016_us_state_500k",
                      GDAL1_integer64_policy = TRUE, verbose = FALSE)

# Remove non-contiguous states/territories
states.shp <- subset(states_shp, !states_shp$STUSPS %in% c("AK", "GU", "MP", "VI", "AS", "PR", "HI"))

# Merge shape and inventory files
states.shp <- sp::merge(states.shp, inventory.map, by = "STUSPS")

stusps <- as.vector(as.character(states.shp@data$STUSPS))

# Read in unit shape file (from US forest service)
units_shp <- readOGR("MapFiles", layer = "eastunits",
                     GDAL1_integer64_policy = TRUE, verbose = FALSE)

# Merge inventory and shape files. Log transform for a more distinct break in heat map colors. 
units.shp <- sp::merge(units_shp, inventory.map.unit, by = "UNIT")
units.shp@data <- units.shp@data[complete.cases(units.shp@data),]
units.shp@data$tot[units.shp@data$tot == 0] <- min(units.shp@data$tot[units.shp@data$tot > 0])-5000
units.shp@data$tot.log <- log(units.shp@data$tot)

# Build map
output$inventory_map_rm <- renderLeaflet({
  
  # Set id to state abbreviation
  id <- as.vector(states.shp@data$STUSPS)
  
  leaflet(units.shp, options = leafletOptions(zoomControl = FALSE))%>%
    addPolygons(color = '#444444', weight = 1, smoothFactor = 0.5,
                opacity = 1.0, fillOpacity = 0.5,
                fillColor = ~colorNumeric("YlGn", tot.log)(tot.log)) %>%
    # Layer transparent state shapes over units for clickable states
    addPolygons(data = states.shp, layerId = id, color = '#000000', weight = 1, smoothFactor = 0.5,
                opacity = 1.0, fillOpacity = 0, label = id,
                highlightOptions = highlightOptions(color = "white", weight = 2,
                                                    bringToFront = TRUE))
  
})

leafletOutput('inventory_map_rm')
```


### Inventory Forecast by State *with 95% Confidence Interval*

```{r echo = F,warning=FALSE,message=FALSE,error=FALSE}
data$STATE_ABBR <- as.character(data$STATE_ABBR)

# renderPlotly for inputs to work
renderPlotly({
  # Store the id from the map click
  st.alt <- as.character(input$inventory_map_rm_shape_click$id)
  
  # Validate statement to return a helpful error if they haven't yet clicked on a state.
  # Filter data to the selected state.  
  validate(need(try(state.data.alt <-
                      filter(data, STATE_ABBR == st.alt))
                , "Click on a state to the left to view the state-level forecast."))
  
  state.data.alt <- state.data.alt[, c(1, 2, 5:7)] %>%
    group_by(STATE_ABBR, EVAL_GRP_YEAR) %>%
    summarise_all(funs(sum(., na.rm = TRUE)))
  
  state.inv.alt <- inv.state.rolled %>%
    select(STATE_ABBR, EVAL_GRP_YEAR, SELECT_WHITE_OAK_INV_CUFT_GS) %>%
    group_by(STATE_ABBR, EVAL_GRP_YEAR) %>%
    summarise(tot = sum(SELECT_WHITE_OAK_INV_CUFT_GS, na.rm = TRUE))
  
  state.mod.alt <-
    merge(state.data.alt, state.inv.alt, by = c("STATE_ABBR", "EVAL_GRP_YEAR"))
  
  colnames(state.mod.alt)[3:6] <-
    c("total.growth",
      "total.mortality",
      "total.removal",
      "inv.gs")
  
  state.mod.alt$growth.change <- state.mod.alt$total.growth / state.mod.alt$inv.gs
  state.mod.alt$mortality.change <- state.mod.alt$total.mortality / state.mod.alt$inv.gs
  state.mod.alt$removal.change <- state.mod.alt$total.removal / state.mod.alt$inv.gs
  
  state.mod.alt <-
    filter(state.mod.alt, EVAL_GRP_YEAR <= 2014 & EVAL_GRP_YEAR >= 1991)
  
  #check for consecutive years
  validate(need(try(state.mod.alt$conesc <- 2), "There is no data associated with the selected state. Please select a colored state on the map to view the state level forecast."))
  
  for(i in 1:(nrow(state.mod.alt)-1)) {
    if((state.mod.alt$EVAL_GRP_YEAR[i+1] == (state.mod.alt$EVAL_GRP_YEAR[i]) + 1)) {
      state.mod.alt$consec[i] <- 0
    } else {
      state.mod.alt$consec[i] <- 1
    }
  }
  
  state.mod.alt$consec[nrow(state.mod.alt)] <- 0 
  
  state.mod.alt <- filter(state.mod.alt, consec == 0)
  
  # Build model
  num.alt <- nrow(state.mod.alt)
  
  # Validate statement to return a helpful error if the selected state does not have associated data.
  validate(need(try(model_growth_st <- lm(growth.change ~ c(1:num.alt), data = state.mod.alt))
                , "There is no forecast available for selected state."))
  model_mortality_st <- lm(mortality.change ~ c(1:num.alt), data = state.mod.alt)
  model_removal_st <- lm(removal.change ~ c(1:num.alt), data = state.mod.alt)
  
  # Store coefficients
  growth_slope_st <- coef(model_growth_st)[[2]]
  mortality_slope_st <- coef(model_mortality_st)[[2]]
  removal_slope_st <- coef(model_removal_st)[[2]]
  
  # Store upper and lower bounds
  growth_slope_upper_st <- confint(model_growth_st)[4]
  growth_slope_lower_st <- confint(model_growth_st)[2]
  
  mortality_slope_upper_st <- confint(model_mortality_st)[4]
  mortality_slope_lower_st <- confint(model_mortality_st)[2]
  
  removal_slope_upper_st <- confint(model_removal_st)[4]
  removal_slope_lower_st <- confint(model_removal_st)[2]
  
  # Use average of 2010 - 2014 as intercept
  for_int <- filter(state.mod.alt, EVAL_GRP_YEAR >= 2010)
  growth_int_st <- mean(for_int$growth.change)
  mortality_int_st <- mean(for_int$mortality.change)
  removal_int_st <- mean(for_int$removal.change)
  
  # Build "forecast" dataframe
  future_st_alt <- NULL
  future_st_alt$year <- 2014:2040
  future_st_alt <- data.frame(future_st_alt)
  
  future_st_alt$inventory <- 0
  future_st_alt$inventory.high <- 0
  future_st_alt$inventory.low <- 0
  future_st_alt$growth <- 0
  future_st_alt$growth.high <- 0
  future_st_alt$growth.low <- 0
  future_st_alt$removals <- 0
  future_st_alt$removal.low <- 0
  future_st_alt$removal.high <- 0
  future_st_alt$mortality <- 0
  future_st_alt$mortality.high <- 0
  future_st_alt$mortality.low <- 0
  future_st_alt$urbanization <- 0
  future_st_alt$urbanization.high <- 0
  future_st_alt$urbanization.low <- 0
  
  # Fill in data for 2014
  inv_14 <- state.mod.alt %>%
    filter(EVAL_GRP_YEAR == 2014) %>%
    select(inv.gs)
  
  future_st_alt$inventory[1] <- as.numeric(inv_14[1, 1])
  future_st_alt$inventory.high[1] <- as.numeric(inv_14[1, 1])
  future_st_alt$inventory.low[1] <- as.numeric(inv_14[1, 1])
  future_st_alt$growth[1] <- state.mod.alt$total.growth[nrow(state.mod.alt)]
  future_st_alt$removals[1] <- state.mod.alt$total.removal[nrow(state.mod.alt)]
  future_st_alt$removal.low[1] <- state.mod.alt$total.removal[nrow(state.mod.alt)]
  future_st_alt$removal.high[1] <- state.mod.alt$total.removal[nrow(state.mod.alt)]
  future_st_alt$mortality[1] <- state.mod.alt$total.mortality[nrow(state.mod.alt)]
  future_st_alt$growth.high[1] <- state.mod.alt$total.growth[nrow(state.mod.alt)]
  future_st_alt$mortality.high[1] <- state.mod.alt$total.mortality[nrow(state.mod.alt)]
  future_st_alt$growth.low[1] <- state.mod.alt$total.growth[nrow(state.mod.alt)]
  future_st_alt$mortality.low[1] <- state.mod.alt$total.mortality[nrow(state.mod.alt)]
  
  # Calculate growth and mortality % "forecast"
  future_st_alt$dummy <- 0:26
  
  future_st_alt$new_growth <- ((future_st_alt$dummy * growth_slope_st) + growth_int_st)
  future_st_alt$new_mortality <- ((future_st_alt$dummy * mortality_slope_st) + mortality_int_st)
  future_st_alt$new_removal <- (future_st_alt$dummy * removal_slope_st) + removal_int_st
  
  future_st_alt$high_growth <- ((future_st_alt$dummy * growth_slope_upper_st) + growth_int_st)
  future_st_alt$high_mortality <- ((future_st_alt$dummy * mortality_slope_upper_st) + mortality_int_st)
  future_st_alt$high_removal <- (future_st_alt$dummy * removal_slope_upper_st) + removal_int_st
  
  future_st_alt$low_growth <- ((future_st_alt$dummy * growth_slope_lower_st) + growth_int_st)
  future_st_alt$low_mortality <- ((future_st_alt$dummy * mortality_slope_lower_st) + mortality_int_st)
  future_st_alt$low_removal <- (future_st_alt$dummy * removal_slope_lower_st) + removal_int_st
  
  # growth, removal, mortality cannot be a negative % of inventory
  future_st_alt$low_removal <- ifelse(future_st_alt$low_removal <= 0, 0, future_st_alt$low_removal)
  future_st_alt$low_growth <- ifelse(future_st_alt$low_growth <= 0, 0, future_st_alt$low_growth)
  future_st_alt$low_mortality <- ifelse(future_st_alt$low_mortality <= 0, 0, future_st_alt$low_mortality)
  
  future_st_alt$high_removal <- ifelse(future_st_alt$high_removal <= 0, 0, future_st_alt$high_removal)
  future_st_alt$high_growth <- ifelse(future_st_alt$high_growth <= 0, 0, future_st_alt$high_growth)
  future_st_alt$high_mortality <- ifelse(future_st_alt$high_mortality <= 0, 0, future_st_alt$high_mortality)
  
  future_st_alt$new_removal <- ifelse(future_st_alt$new_removal <= 0, 0, future_st_alt$new_removal)
  future_st_alt$new_growth <- ifelse(future_st_alt$new_growth <= 0, 0, future_st_alt$new_growth)
  future_st_alt$new_mortality <- ifelse(future_st_alt$new_mortality <= 0, 0, future_st_alt$new_mortality)
  
  future_st_alt$dummy <- NULL
  
  # fill in forecast table row by row
  for (i in 2:nrow(future_st_alt)) {
    future_st_alt$inventory[i] <-
      future_st_alt$inventory[i - 1] + future_st_alt$growth[i - 1] - future_st_alt$removals[i - 1] - future_st_alt$mortality[i - 1] - future_st_alt$urbanization[i - 1]
    
    future_st_alt$inventory.high[i] <-
      future_st_alt$inventory.high[i - 1] + future_st_alt$growth.high[i - 1] - future_st_alt$removal.low[i - 1] - future_st_alt$mortality.low[i - 1] - future_st_alt$urbanization.high[i - 1]
    
    future_st_alt$inventory.low[i] <-
      future_st_alt$inventory.low[i - 1] + future_st_alt$growth.low[i - 1] - future_st_alt$removal.high[i - 1] - future_st_alt$mortality.high[i - 1] - future_st_alt$urbanization.low[i - 1]
    
    future_st_alt$growth[i] <- future_st_alt$inventory[i] * (future_st_alt$new_growth[i])
    future_st_alt$growth.high[i] <- future_st_alt$inventory.high[i] * (future_st_alt$high_growth[i])
    future_st_alt$growth.low[i] <- future_st_alt$inventory.low[i] * (future_st_alt$low_growth[i])      
    
    future_st_alt$mortality[i] <- future_st_alt$inventory[i] * (future_st_alt$new_mortality[i])
    future_st_alt$mortality.high[i] <- future_st_alt$inventory.low[i] * (future_st_alt$high_mortality[i])
    future_st_alt$mortality.low[i] <- future_st_alt$inventory.high[i] * (future_st_alt$low_mortality[i])
    
    future_st_alt$removals[i] <- future_st_alt$inventory[i] * (future_st_alt$new_removal[i])
    future_st_alt$removal.high[i] <- future_st_alt$inventory.low[i] * future_st_alt$high_removal[i]
    future_st_alt$removal.low[i] <- future_st_alt$inventory.high[i] * future_st_alt$low_removal[i]
    
    future_st_alt$urbanization[i] <- future_st_alt$inventory[i] * (as.numeric(input$urbanization2) / 100)
    future_st_alt$urbanization.high[i] <- future_st_alt$inventory.high[i] * (as.numeric(input$urbanization2) / 100)
    future_st_alt$urbanization.low[i] <- future_st_alt$inventory.low[i] * (as.numeric(input$urbanization2) / 100)
    
  }
  
  future_st_alt$inventory <- round(as.numeric(future_st_alt$inventory),0)
  future_st_alt$inventory.high <- round(as.numeric(future_st_alt$inventory.high),0)
  future_st_alt$inventory.low <- round(as.numeric(future_st_alt$inventory.low),0)    
  
  future_plt <- select(future_st_alt, year, inventory, inventory.high, inventory.low)
  
  future_plt <- tidyr::gather(future_plt, 
                              key = 'type', 
                              value = 'forecast', 
                              -year)
  
  future_plt$forecast_div <- future_plt$forecast/1000000000
  future_plt$bounds <- ifelse(future_plt$type == "inventory", "n", "y")
  
  future_plt$bounds <- factor(future_plt$bounds, levels = c("y", "n"))
  
  plt_st_alt <- ggplot(data = future_plt, aes(x = year, y = forecast_div, linetype = bounds, colour = bounds, size = bounds, group = type)) + 
    geom_line(aes(text = paste0("Year: ", year, "<br>Forecast: ", formattable::comma(forecast)))) +
    scale_colour_manual(values = c("maroon", "darkgreen")) +
    scale_linetype_manual(values = c(3,1)) +
    scale_size_manual(values = c(1,1)) +
    theme(panel.background = element_blank(),
          axis.line = element_line(colour = "black"),
          legend.position = 'none') +
    ylab(paste0(unique(state.mod.alt$STATE_ABBR)," Inventory (Billions, Cubic Feet)")) +
    xlab("")
  
  
  ggplotly(plt_st_alt, tooltip = 'text')
  
})
```

Alternate Forecast
=======================================================================

Inputs {.sidebar}
-----------------------------------------------------------------------

\

\

Use the sliding bars below to adjust the increase in Annual Removal and Urbanization to see the effect these factors can have on the White Oak Population.

\

```{r echo = F,warning=FALSE,message=FALSE,error=FALSE}
tags$style(HTML(".sidebarPanel .body {background-color: lightgrey;}"))

tags$style(HTML(".js-irs-0 .irs-single, .js-irs-0 .irs-bar-edge, .js-irs-0 .irs-bar {background: green}"))
tags$style(HTML(".js-irs-1 .irs-single, .js-irs-1 .irs-bar-edge, .js-irs-1 .irs-bar {background: green}"))

sliderInput("removal", label = "Annual Removal Increase (%):",
            min = 0.0, max = 1.0, value = 0.5, step = 0.1)

sliderInput("urbanization", label = "Annual Urbanization (% of White Oak Inventory):",
            min = 0.0, max = 1.0, value = 0.1, step = 0.1)
```

\

\

*See **Documentation** for explanation of forecast methods.*

Row
-----------------------------------------------------------------------

### White Oak Inventory Forecast *with 95% Confidence Interval*

```{r echo = F,warning=FALSE,message=FALSE,error=FALSE}
# Build "forecast" dataframe
future <- NULL
future$year <- 2014:2064
future <- data.frame(future)

future$inventory <- 0
future$inventory.high <- 0
future$inventory.low <- 0
future$growth <- 0
future$growth.high <- 0
future$growth.low <- 0
future$removals <- 0
future$mortality <- 0
future$mortality.high <- 0
future$mortality.low <- 0
future$urbanization <- 0
future$urbanization.high <- 0
future$urbanization.low <- 0
future$demand <- 0
future$`demand % of inventory` <- 0
future$`demand % of removals` <- 0

# Fill in data for 2014
inv_14 <- inventory_national %>% 
  filter(EVAL_GRP_YEAR == 2014) %>% 
  select(SELECT_WHITE_OAK_INV_CUFT_GS)

future$inventory[1] <- as.numeric(inv_14[1,1])
future$inventory.high[1] <- as.numeric(inv_14[1,1])
future$inventory.low[1] <- as.numeric(inv_14[1,1])
future$growth[1] <- national$total.growth[nrow(national)]
future$removals[1] <- national$total.removal[nrow(national)]
future$mortality[1] <- national$total.mortality[nrow(national)]
future$growth.high[1] <- national$total.growth[nrow(national)]
future$mortality.high[1] <- national$total.mortality[nrow(national)]
future$growth.low[1] <- national$total.growth[nrow(national)]
future$mortality.low[1] <- national$total.mortality[nrow(national)]

# Calculate growth and mortality % "forecast"
future$dummy <- 0:50

future$new_growth <- ((future$dummy*growth_slope)+growth_int)
future$new_mortality <- ((future$dummy*mortality_slope)+mortality_int)

future$high_growth <- ((future$dummy*growth_slope_upper)+growth_int)
future$high_mortality <- ((future$dummy*mortality_slope_upper)+mortality_int)

future$low_growth <- ((future$dummy*growth_slope_lower)+growth_int)
future$low_mortality <- ((future$dummy*mortality_slope_lower)+mortality_int)

# Cannot be negative % of inventory
future$low_growth <- ifelse(future$low_growth <= 0, 0, future$low_growth)
future$low_mortality <- ifelse(future$low_mortality <= 0, 0, future$low_mortality)

future$high_growth <- ifelse(future$high_growth <= 0, 0, future$high_growth)
future$high_mortality <- ifelse(future$high_mortality <= 0, 0, future$high_mortality)

future$new_growth <- ifelse(future$new_growth <= 0, 0, future$new_growth)
future$new_mortality <- ifelse(future$new_mortality <= 0, 0, future$new_mortality)

future$dummy <- NULL

# renderPlot for inputs to work
# renderggiraph for ggiraph graph
# renderPlotly for plotly graph

renderPlotly({
  
  # fill in forecast table row by row
  for (i in 2:nrow(future)) {
    future$inventory[i] <- future$inventory[i-1] + future$growth[i-1] - future$removals[i-1] - future$mortality[i-1] - future$urbanization[i-1]
    
    future$inventory.high[i] <- future$inventory.high[i-1] + future$growth.high[i-1] - future$removals[i-1] - future$mortality.low[i-1] - future$urbanization.high[i-1]
    
    future$inventory.low[i] <- future$inventory.low[i-1] + future$growth.low[i-1] - future$removals[i-1] - future$mortality.high[i-1] - future$urbanization.low[i-1]
    
    future$growth[i] <- future$inventory[i]*(future$new_growth[i])
    future$growth.high[i] <- future$inventory.high[i]*(future$high_growth[i])
    future$growth.low[i] <- future$inventory.low[i]*(future$low_growth[i])
    
    future$mortality[i] <- future$inventory[i]*(future$new_mortality[i])
    future$mortality.high[i] <- future$inventory.low[i]*(future$high_mortality[i])
    future$mortality.low[i] <- future$inventory.high[i]*(future$low_mortality[i])
    
    future$removals[i] <- future$removals[i-1]*((1 + as.numeric(input$removal)/100))
    
    future$urbanization[i] <- future$inventory[i]*(as.numeric(input$urbanization)/100)
    future$urbanization.high[i] <- future$inventory.high[i]*(as.numeric(input$urbanization)/100)
    future$urbanization.low[i] <- future$inventory.low[i]*(as.numeric(input$urbanization)/100)
    
  }
  
  future$inventory <- round(as.numeric(future$inventory),0)
  future$inventory.high <- round(as.numeric(future$inventory.high),0)
  future$inventory.low <- round(as.numeric(future$inventory.low),0)
  
  future_plt <- select(future, year, inventory, inventory.high, inventory.low)
  
  future_plt <- tidyr::gather(future_plt, 
                              key = 'type', 
                              value = 'forecast', 
                              -year)
  
  future_plt$forecast_div <- future_plt$forecast/1000000000
  future_plt$bounds <- ifelse(future_plt$type == "inventory", "n", "y")
  
  future_plt$bounds <- factor(future_plt$bounds, levels = c("y", "n"))
  
  plt <- ggplot(data = future_plt, aes(x = year, y = forecast_div, linetype = bounds, colour = bounds, size = bounds, group = type)) + 
    geom_line(aes(text = paste0("Year: ", year, "<br>Forecast: ", formattable::comma(forecast)))) +
    scale_colour_manual(values = c("maroon", "darkgreen")) +
    scale_linetype_manual(values = c(3,1)) +
    scale_size_manual(values = c(1,1)) +
    theme(panel.background = element_blank(),
          axis.line = element_line(colour = "black"),
          legend.position = 'none') +
    ylab("Inventory (Billions, Cubic Feet)") +
    xlab("") +
    scale_y_continuous(limits = c(0,110))
  
  
  ggplotly(plt, tooltip = 'text')
  
})
```


Row 
-----------------------------------------------------------------------

### Current Inventory (2014) by FIA Unit

```{r echo = F,warning=FALSE,message=FALSE,error=FALSE}
inventory.map <- inv.state.rolled %>%
  select(STATE_ABBR, EVAL_GRP_YEAR, SELECT_WHITE_OAK_INV_CUFT_GS) %>%
  group_by(STATE_ABBR, EVAL_GRP_YEAR) %>%
  summarise(tot = sum(SELECT_WHITE_OAK_INV_CUFT_GS, na.rm = TRUE)) %>%
  filter(EVAL_GRP_YEAR == 2014)

inventory.map.unit <- inv.unit.rolled %>%
  select(STATE_ABBR, EVAL_GRP_YEAR, UNIT, SELECT_WHITE_OAK_INV_CUFT_GS) %>%
  group_by(STATE_ABBR, EVAL_GRP_YEAR, UNIT) %>%
  summarise(tot = sum(SELECT_WHITE_OAK_INV_CUFT_GS)) %>%
  filter(EVAL_GRP_YEAR == 2014)

colnames(inventory.map)[1] <- "STUSPS"

states_shp <- readOGR("MapFiles", layer = "cb_2016_us_state_500k",
                      GDAL1_integer64_policy = TRUE, verbose = FALSE)

states.shp <- subset(states_shp, !states_shp$STUSPS %in% c("AK", "GU", "MP", "VI", "AS", "PR", "HI"))

states.shp <- sp::merge(states.shp, inventory.map, by = "STUSPS")

stusps <- as.vector(as.character(states.shp@data$STUSPS))

units_shp <- readOGR("MapFiles", layer = "eastunits",
                     GDAL1_integer64_policy = TRUE, verbose = FALSE)

units.shp <- sp::merge(units_shp, inventory.map.unit, by = "UNIT")
units.shp@data <- units.shp@data[complete.cases(units.shp@data),]
units.shp@data$tot[units.shp@data$tot == 0] <- min(units.shp@data$tot[units.shp@data$tot > 0])-5000
units.shp@data$tot.log <- log(units.shp@data$tot)

output$inventory_map <- renderLeaflet({
  
  id <- as.vector(states.shp@data$STUSPS)
  
  leaflet(units.shp, options = leafletOptions(zoomControl = FALSE))%>%
    addPolygons(color = '#444444', weight = 1, smoothFactor = 0.5,
                opacity = 1.0, fillOpacity = 0.5,
                fillColor = ~colorNumeric("YlGn", tot.log)(tot.log)) %>%
    addPolygons(data = states.shp, layerId = id, color = '#000000', weight = 1, smoothFactor = 0.5,
                opacity = 1.0, fillOpacity = 0, label = id,
                highlightOptions = highlightOptions(color = "white", weight = 2,
                                                    bringToFront = TRUE))
  
})

leafletOutput('inventory_map')
```


### Inventory Forecast by State *with 95% Confidence Interval*

```{r echo = F,warning=FALSE,message=FALSE,error=FALSE}
renderPlotly({
  
  st <- as.character(input$inventory_map_shape_click$id)
  
  validate(need(try(state.data <-
                      filter(data, STATE_ABBR == st))
                , "Click on a state to the left to view the state-level forecast."))
  
  state.data <- state.data[, c(1, 2, 5:7)] %>%
    group_by(STATE_ABBR, EVAL_GRP_YEAR) %>%
    summarise_all(funs(sum(., na.rm = TRUE)))
  
  state.inv <- inv.state.rolled %>%
    select(STATE_ABBR, EVAL_GRP_YEAR, SELECT_WHITE_OAK_INV_CUFT_GS) %>%
    group_by(STATE_ABBR, EVAL_GRP_YEAR) %>%
    summarise(tot = sum(SELECT_WHITE_OAK_INV_CUFT_GS, na.rm = TRUE))
  
  state.mod <-
    merge(state.data, state.inv, by = c("STATE_ABBR", "EVAL_GRP_YEAR"))
  
  colnames(state.mod)[3:6] <-
    c("total.growth",
      "total.mortality",
      "total.removal",
      "inv.gs")
  
  state.mod$growth.change <- state.mod$total.growth / state.mod$inv.gs
  state.mod$mortality.change <- state.mod$total.mortality / state.mod$inv.gs
  state.mod$removal.change <- state.mod$total.removal / state.mod$inv.gs
  
  state.mod <- filter(state.mod, EVAL_GRP_YEAR <= 2014 & EVAL_GRP_YEAR >= 1991)
  
  #check for consecutive years
  state.mod$conesc <- 2
  
  for(i in 1:(nrow(state.mod)-1)) {
    if((state.mod$EVAL_GRP_YEAR[i+1] == (state.mod$EVAL_GRP_YEAR[i]) + 1)) {
      state.mod$consec[i] <- 0
    } else {
      state.mod$consec[i] <- 1
    }
  }
  
  state.mod$consec[nrow(state.mod)] <- 0 
  
  state.mod <- filter(state.mod, consec == 0)
  
  # Build model
  num <- nrow(state.mod)
  
  validate(need(try(model_growth_st <- lm(growth.change ~ c(1:num), data = state.mod))
                , "There is no forecast available for selected state."))
  model_mortality_st <- lm(mortality.change ~ c(1:num), data = state.mod)
  model_removal_st <- lm(removal.change ~ c(1:num), data = state.mod)
  
  # Store coefficients
  growth_slope <- coef(model_growth_st)[[2]]
  mortality_slope <- coef(model_mortality_st)[[2]]
  removal_slope <- coef(model_removal_st)[[2]]
  
  # Store upper and lower bounds
  growth_slope_upper <- confint(model_growth_st)[4]
  growth_slope_lower <- confint(model_growth_st)[2]
  
  mortality_slope_upper <- confint(model_mortality_st)[4]
  mortality_slope_lower <- confint(model_mortality_st)[2]
  
  removal_slope_upper <- confint(model_removal_st)[4]
  removal_slope_lower <- confint(model_removal_st)[2]
  
  # Use average of 2010 - 2014 as intercept
  for_int <- filter(state.mod, EVAL_GRP_YEAR >= 2010)
  growth_int <- mean(for_int$growth.change)
  mortality_int <- mean(for_int$mortality.change)
  removal_int <- mean(for_int$removal.change)
  
  # Build "forecast" dataframe
  future_st <- NULL
  future_st$year <- 2014:2040
  future_st <- data.frame(future_st)
  
  future_st$inventory <- 0
  future_st$inventory.high <- 0
  future_st$inventory.low <- 0
  future_st$growth <- 0
  future_st$growth.high <- 0
  future_st$growth.low <- 0
  future_st$removals <- 0
  future_st$mortality <- 0
  future_st$mortality.high <- 0
  future_st$mortality.low <- 0
  future_st$urbanization <- 0
  future_st$urbanization.high <- 0
  future_st$urbanization.low <- 0
  
  # Fill in data for 2014
  inv_14 <- state.mod %>%
    filter(EVAL_GRP_YEAR == 2014) %>%
    select(inv.gs)
  
  future_st$inventory[1] <- as.numeric(inv_14[1, 1])
  future_st$inventory.high[1] <- as.numeric(inv_14[1, 1])
  future_st$inventory.low[1] <- as.numeric(inv_14[1, 1])
  future_st$growth[1] <- state.mod$total.growth[nrow(state.mod)]
  future_st$removals[1] <- state.mod$total.removal[nrow(state.mod)]
  future_st$mortality[1] <- state.mod$total.mortality[nrow(state.mod)]
  future_st$growth.high[1] <- state.mod$total.growth[nrow(state.mod)]
  future_st$mortality.high[1] <- state.mod$total.mortality[nrow(state.mod)]
  future_st$growth.low[1] <- state.mod$total.growth[nrow(state.mod)]
  future_st$mortality.low[1] <- state.mod$total.mortality[nrow(state.mod)]
  
  # Calculate growth and mortality % "forecast"
  future_st$dummy <- 0:26
  
  future_st$new_growth <- ((future_st$dummy * growth_slope) + growth_int)
  future_st$new_mortality <- ((future_st$dummy * mortality_slope) + mortality_int)
  
  future_st$high_growth <- ((future_st$dummy * growth_slope_upper) + growth_int)
  future_st$high_mortality <- ((future_st$dummy * mortality_slope_upper) + mortality_int)
  
  future_st$low_growth <- ((future_st$dummy * growth_slope_lower) + growth_int)
  future_st$low_mortality <- ((future_st$dummy * mortality_slope_lower) + mortality_int)
  
  # Cannot be negative % of inventory
  future_st$low_growth <- ifelse(future_st$low_growth <= 0, 0, future_st$low_growth)
  future_st$low_mortality <- ifelse(future_st$low_mortality <= 0, 0, future_st$low_mortality)
  future_st$high_growth <- ifelse(future_st$high_growth <= 0, 0, future_st$high_growth)
  future_st$high_mortality <- ifelse(future_st$high_mortality <= 0, 0, future_st$high_mortality)
  future_st$new_growth <- ifelse(future_st$new_growth <= 0, 0, future_st$new_growth)
  future_st$new_mortality <- ifelse(future_st$new_mortality <= 0, 0, future_st$new_mortality)
  
  future_st$dummy <- NULL
  
  # fill in forecast table row by row
  for (i in 2:nrow(future_st)) {
    future_st$inventory[i] <- future_st$inventory[i - 1] + future_st$growth[i - 1] - future_st$removals[i - 1] - future_st$mortality[i - 1] - future_st$urbanization[i - 1]
    
    future_st$inventory.high[i] <- future_st$inventory.high[i - 1] + future_st$growth.high[i - 1] - future_st$removals[i - 1] - future_st$mortality.low[i - 1] - future_st$urbanization.high[i - 1]
    
    future_st$inventory.low[i] <- future_st$inventory.low[i - 1] + future_st$growth.low[i - 1] - future_st$removals[i - 1] - future_st$mortality.high[i - 1] - future_st$urbanization.low[i - 1]
    
    future_st$growth[i] <- future_st$inventory[i] * (future_st$new_growth[i])
    future_st$growth.high[i] <- future_st$inventory.high[i] * (future_st$high_growth[i])
    future_st$growth.low[i] <- future_st$inventory.low[i] * (future_st$low_growth[i])
    
    future_st$mortality[i] <- future_st$inventory[i] * (future_st$new_mortality[i])
    future_st$mortality.high[i] <- future_st$inventory.low[i] * (future_st$high_mortality[i])
    future_st$mortality.low[i] <- future_st$inventory.high[i] * (future_st$low_mortality[i])
    
    future_st$removals[i] <- future_st$removals[i - 1] * ((1 + as.numeric(input$removal) / 100))
    
    future_st$urbanization[i] <- future_st$inventory[i] * (as.numeric(input$urbanization) / 100)
    future_st$urbanization.high[i] <- future_st$inventory.high[i] * (as.numeric(input$urbanization) / 100)
    future_st$urbanization.low[i] <- future_st$inventory.low[i] * (as.numeric(input$urbanization) / 100)
    
  }
  
  future_st$inventory <- round(as.numeric(future_st$inventory),0)
  future_st$inventory.high <- round(as.numeric(future_st$inventory.high),0)
  future_st$inventory.low <- round(as.numeric(future_st$inventory.low),0)  
  
  future_plt <- select(future_st, year, inventory, inventory.high, inventory.low)
  
  future_plt <- tidyr::gather(future_plt, 
                              key = 'type', 
                              value = 'forecast', 
                              -year)
  
  future_plt$forecast_div <- future_plt$forecast/1000000000
  
  future_plt$bounds <- ifelse(future_plt$type == "inventory", "n", "y")
  
  future_plt$bounds <- factor(future_plt$bounds, levels = c("y", "n"))
  
  plt_st <- ggplot(data = future_plt, aes(x = year, y = forecast_div, linetype = bounds, colour = bounds, size = bounds, group = type)) + 
    geom_line(aes(text = paste0("Year: ", year, "<br>Forecast: ", formattable::comma(forecast)))) +
    scale_colour_manual(values = c("maroon", "darkgreen")) +
    scale_linetype_manual(values = c(3,1)) +
    scale_size_manual(values = c(1,1)) +
    theme(panel.background = element_blank(),
          axis.line = element_line(colour = "black"),
          legend.position = 'none') +
    ylab(paste0(unique(state.mod$STATE_ABBR)," Inventory (Billions, Cubic Feet)")) +
    xlab("")
  
  ggplotly(plt_st, tooltip = 'text')
  
})
```


Forecast Data
=======================================================================

Inputs {.sidebar}
-----------------------------------------------------------------------

\

The data displayed to the right includes the values selected for Annual increase in Removal and/or Urbanization from the prior tabs. 

\


```{r}
selectInput("forecast_type", label = "Please select which forecast you would like to view:", choices = c("Forecast", "Alternate Forecast"), selected = "Forecast")
```

Enter Brown-Forman's demand for White Oak in the year `r max(data$EVAL_GRP_YEAR)-3`:

\

```{r}
numericInput("demand", label = paste0("Brown-Forman ", max(data$EVAL_GRP_YEAR)-3," Demand:"), 360000, min = 0, max = 1000000000)
```

\

Use the sliding bar below to adjust the increase in Annual Demand to analyze the portion of Total Inventory and Total Removal that B-F Demand occupies.

```{r}
tags$style(HTML(".js-irs-3 .irs-single, .js-irs-3 .irs-bar-edge, .js-irs-3 .irs-bar {background: green}"))

sliderInput("bf_demand", label = "Brown-Forman Annual Demand Increase (%):",
            min = 0.0, max = 20.0, value = 10.0, step = 0.5)
```

Row
-----------------------------------------------------------------------

```{r echo = F,warning=FALSE,message=FALSE,error=FALSE}
renderTable({
  
  if (input$forecast_type == "Alternate Forecast") {  
    
    future$demand[1] <- as.numeric(input$demand)
    future$`demand % of inventory` <- (future$demand[1]/future$inventory[1])*100
    future$`demand % of removals` <- (future$demand[1]/future$removals[1])*100
    
    # fill in forecast table row by row
    for (i in 2:nrow(future)) {
      future$inventory[i] <- future$inventory[i-1] + future$growth[i-1] - future$removals[i-1] - future$mortality[i-1] - future$urbanization[i-1]
      
      future$inventory.high[i] <- future$inventory.high[i-1] + future$growth.high[i-1] - future$removals[i-1] - future$mortality.low[i-1] - future$urbanization.high[i-1]
      
      future$inventory.low[i] <- future$inventory.low[i-1] + future$growth.low[i-1] - future$removals[i-1] - future$mortality.high[i-1] - future$urbanization.low[i-1]
      
      future$growth[i] <- future$inventory[i]*(future$new_growth[i])
      future$growth.high[i] <- future$inventory.high[i]*(future$high_growth[i])
      future$growth.low[i] <- future$inventory.low[i]*(future$low_growth[i])
      
      future$mortality[i] <- future$inventory[i]*(future$new_mortality[i])
      future$mortality.high[i] <- future$inventory.low[i]*(future$high_mortality[i])
      future$mortality.low[i] <- future$inventory.high[i]*(future$low_mortality[i])
      
      future$removals[i] <- future$removals[i-1]*((1 + as.numeric(input$removal)/100))
      
      future$urbanization[i] <- future$inventory[i]*(as.numeric(input$urbanization)/100)
      future$urbanization.high[i] <- future$inventory.high[i]*(as.numeric(input$urbanization)/100)
      future$urbanization.low[i] <- future$inventory.low[i]*(as.numeric(input$urbanization)/100)
      
      future$demand[i] <- future$demand[i-1]*(1+(as.numeric(input$bf_demand)/100))
      future$`demand % of inventory`[i] <- (future$demand[i]/future$inventory[i])*100
      future$`demand % of removals`[i] <- (future$demand[i]/future$removals[i])*100
      
    }
    
    future <- select(future, year, inventory, growth, removals, mortality, demand, `demand % of inventory`, `demand % of removals`)
    future$inventory <- round(formattable::comma(as.numeric(future$inventory),0))
    future$growth <- round(formattable::comma(as.numeric(future$growth),0))
    future$removals <- round(formattable::comma(as.numeric(future$removals),0))
    future$mortality <- round(formattable::comma(as.numeric(future$mortality),0))
    future$demand <- round(formattable::comma(as.numeric(future$demand),0))
    future$`demand % of inventory` <- formattable::percent(future$`demand % of inventory`, digits = 3)
    future$`demand % of removals` <- formattable::percent(future$`demand % of removals`, digits = 3)
    colnames(future) <- c("Year", "Inventory", "Growth", "Removals", "Mortality", "Demand", "Demand % of Inventory", "Demand % of Removals")
    future
    
  } else {
    
    future_alt$demand[1] <- as.numeric(input$demand)
    future_alt$`demand % of inventory` <- (future_alt$demand[1]/future_alt$inventory[1])*100
    future_alt$`demand % of removals` <- (future_alt$demand[1]/future_alt$removals[1])*100
    
    # fill in forecast table row by row
    for (i in 2:nrow(future_alt)) {
      # Inventory = Inventory + Growth - Removal - Mortality - Urbanization  
      future_alt$inventory[i] <- future_alt$inventory[i-1] + future_alt$growth[i-1] - future_alt$removals[i-1] - future_alt$mortality[i-1] - future_alt$urbanization[i-1]
      
      # Upper Bound Inventory = Upper Bound Inventory + High Growth - Low Removal - Low Mortality - High Urbanization (i.e. the Urbanization calculated from the High Inventory)
      future_alt$inventory.high[i] <- future_alt$inventory.high[i-1] + future_alt$growth.high[i-1] - future_alt$removal.low[i-1] - future_alt$mortality.low[i-1] - future_alt$urbanization.high[i-1]
      
      # Lower Bound Inventory = Lower Bound Inventory + Low Growth - High Removal - High Mortality - Low Urbanization (i.e. the Urbanization calculated from the Low Inventory)
      future_alt$inventory.low[i] <- future_alt$inventory.low[i-1] + future_alt$growth.low[i-1] - future_alt$removal.high[i-1] - future_alt$mortality.high[i-1] - future_alt$urbanization.low[i-1]
      
      future_alt$growth[i] <- future_alt$inventory[i]*(future_alt$new_growth[i])    
      future_alt$growth.high[i] <- future_alt$inventory.high[i]*(future_alt$high_growth[i])
      future_alt$growth.low[i] <- future_alt$inventory.low[i]*(future_alt$low_growth[i])
      
      future_alt$mortality[i] <- future_alt$inventory[i]*(future_alt$new_mortality[i])
      future_alt$mortality.high[i] <- future_alt$inventory.low[i]*(future_alt$high_mortality[i])
      future_alt$mortality.low[i] <- future_alt$inventory.high[i]*(future_alt$low_mortality[i])
      
      future_alt$removals[i] <- future_alt$inventory[i]*future_alt$new_removal[i]
      future_alt$removal.high[i] <- future_alt$inventory.low[i]*future_alt$high_removal[i]
      future_alt$removal.low[i] <- future_alt$inventory.high[i]*future_alt$low_removal[i]
      
      future_alt$urbanization[i] <- future_alt$inventory[i]*(as.numeric(input$urbanization2)/100)
      future_alt$urbanization.high[i] <- future_alt$inventory.high[i]*(as.numeric(input$urbanization2)/100)
      future_alt$urbanization.low[i] <- future_alt$inventory.low[i]*(as.numeric(input$urbanization2)/100)
      
      future_alt$demand[i] <- future_alt$demand[i-1]*(1+(as.numeric(input$bf_demand)/100))
      future_alt$`demand % of inventory`[i] <- (future_alt$demand[i]/future_alt$inventory[i])*100
      future_alt$`demand % of removals`[i] <- (future_alt$demand[i]/future_alt$removals[i])*100
    }
    
    future_alt <- select(future_alt, year, inventory, growth, removals, mortality, demand, `demand % of inventory`, `demand % of removals`)
    future_alt$inventory <- round(formattable::comma(as.numeric(future_alt$inventory),0))
    future_alt$growth <- round(formattable::comma(as.numeric(future_alt$growth),0))
    future_alt$removals <- round(formattable::comma(as.numeric(future_alt$removals),0))
    future_alt$mortality <- round(formattable::comma(as.numeric(future_alt$mortality),0))
    future_alt$demand <- round(formattable::comma(as.numeric(future_alt$demand),0))
    future_alt$`demand % of inventory` <- formattable::percent(future_alt$`demand % of inventory`, digits = 3)
    future_alt$`demand % of removals` <- formattable::percent(future_alt$`demand % of removals`, digits = 3)
    colnames(future_alt) <- c("Year", "Inventory", "Growth", "Removals", "Mortality", "Demand", "Demand % of Inventory", "Demand % of Removals")
    future_alt
    
  }
  
})
```

Documentation
=======================================================================

#### Data

The data used for this analysis was received from the U.S. Forest Service. The data contains annual, unit level volumes for White Oak on private, non-industrial lands in the Eastern states, and includes detail on the Growing Stock Inventory, Growth, Removal, and Mortality in cubic feet. The data spans the period 1991 through 2014.

#### Method

##### *Forecast*

In order to forecast the White Oak population, we first calculated the yearly percent of inventory for the growth, removal, and mortality volumes. We then built a simple linear regression model to describe the trend of the growth, removal, and mortality, individually. Using the slope coefficient and an intercept based off the average of the percent of inventory for 2010 to 2014, we predicted the growth, removal, and mortality percent of inventory for the years 2015 through 2064. Using these values, as well as user-input values for annual urbanization percent of inventory, we calculated a forecast for the White Oak inventory.

As well as an inventory forecast, we also provide an upper bound and a lower bound (95% confidence interval), based off of the upper and lower estimates for the slope coefficient from the model. The 95% confidence interval means that we are 95% confident that the true values lies somewhere between the upper and lower bounds.

##### *Alternate Forecast*

We used the same methods to compile the alternate forecast, but instead of forecasting removal, we leave it as a user-defined field, similar to how the previous consultants compiled the forecast. 

However, we believe that predicting removal in the same manner as growth and mortality provides a better picture of the forecast, as the historic data could provide a better indication of the future trend rather than leaving it to the user to define.

#### Comments

Since we are only using 23 annual data points to build this forecast, it is important to use caution when interpreting these results further into the forecast horizon. As you look out past ten years, the forecasts serve best as a directional indication of the White Oak population.

The state forecast is only provided through 2040 due to a lack of data at the state level (the forecast for some states is based off of less than 10 years of data).